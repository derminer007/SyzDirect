index 24b78d9d0..5c2bd729b 100644
--- a/workdir/srcs/case_0/net/tipc/crypto.c
+++ b/workdir/srcs/case_0/net/tipc/crypto.c
@@ -34,6 +34,7 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include <linux/kcov.h>
 #include <crypto/aead.h>
 #include <kunit/test-bug.h>
 #include <crypto/aes.h>
@@ -2279,6 +2280,7 @@ static int tipc_crypto_key_xmit(struct net *net, struct tipc_aead_key *skey,
 static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 {
 
+	kcov_mark_block(3);
 	struct tipc_crypto *tx  = NULL;
 	struct tipc_aead_key *skey = NULL;
 	u16 key_gen = msg_key_gen(hdr);
@@ -2287,12 +2289,14 @@ static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 	unsigned int keylen;
 	
 	if(rx->net){
+		kcov_mark_block(4);
 		tx = tipc_net(rx->net)->crypto_tx;
 	}
 	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
 
 	spin_lock(&rx->lock);
 	if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
+		kcov_mark_block(5);
 		pr_err("%s: key existed <%p>, gen %d vs %d\n", rx->name,
 		       rx->skey, key_gen, rx->key_gen);
 		goto exit;
@@ -2301,6 +2305,7 @@ static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 	/* Allocate memory for the key */
 	skey = kmalloc(size, GFP_ATOMIC);
 	if (unlikely(!skey)) {
+		kcov_mark_block(6);
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
 		goto exit;
 	}
@@ -2318,6 +2323,7 @@ static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 	mb(); /* for nokey flag */
 
 exit:
+	kcov_mark_block(7);
 	spin_unlock(&rx->lock);
 	/* Schedule the key attaching on this crypto */
 	if (rx->net){
